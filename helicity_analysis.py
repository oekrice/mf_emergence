#New script to do helicity analysis on both the original LARE 'magnetograms' and anything generated by MF. Used to determine the 'best' value for the myserious omega.


import numpy as np
import matplotlib.pyplot as plt
import sys
import matplotlib
from scipy.io import netcdf_file
from scipy.interpolate import RegularGridInterpolator
from scipy.fft import fft, ifft2, fft2, ifft
import os
from scipy.ndimage import gaussian_filter

class Grid():
    """In the interest of doing it properly, put grid parameters in here"""
    def __init__(self, run):

        paras = np.loadtxt('parameters/variables%03d.txt' % run)

        import_resolution = 128

        #Define the grid onto which the electric field should be outputted
        self.nx = import_resolution
        self.ny = import_resolution

        self.x0 = paras[12]; self.x1 = paras[13]
        self.y0 = paras[14]; self.y1 = paras[15]

        self.xs = np.linspace(self.x0, self.x1, self.nx+1)
        self.ys = np.linspace(self.y0, self.y1, self.ny+1)

        self.dx = self.xs[1] - self.xs[0]
        self.dy = self.ys[1] - self.ys[0]

        self.xc = np.linspace(self.x0 - self.dx/2, self.x1 + self.dx/2, self.nx+2)
        self.yc = np.linspace(self.y0 - self.dy/2, self.y1 + self.dy/2, self.ny+2)

        self.dx = self.xs[1] - self.xs[0]
        self.dy = self.ys[1] - self.ys[0]

        self.xs_import = np.linspace(self.x0, self.x1, import_resolution+1)
        self.ys_import = np.linspace(self.y0, self.y1, import_resolution+1)


        self.dx_import = self.xs[1] - self.xs[0]
        self.dy_import = self.ys[1] - self.ys[0]

        self.xc_import = np.linspace(self.x0 - self.dx/2, self.x1 + self.dx/2, import_resolution+2)
        self.yc_import = np.linspace(self.y0 - self.dy/2, self.y1 + self.dy/2, import_resolution+2)


class compute_inplane_helicity():
    #Uses all three components of the magnetic field to give values for A.B at EACH of the input timesteps.
    #Requires the script from Chris' flt code
    def __init__(self, run_min, run_max):

        h_ref = []
        h_all = [[] for _ in range(run_max - run_min)]

        #Call run = -1 the reference case
        runs = [-1] + np.arange(run_min, run_max).tolist()

        for ri, run in enumerate(runs):

            grid = Grid(max(run, 0))  #Establish grid (on new scales, not 128)

            for snap in range(0,500,10):

                if (snap%10) == 0:
                    print('Run', run, ', snap', snap)
                #Find from LARE

                if run < 0:
                    source = './magnetograms/'
                else:
                    source = './mf_mags/%03d/' % run

                data_directory = source

                bfield_fname = '%s%04d.nc' % (data_directory, snap)

                try:
                    data = netcdf_file(bfield_fname, 'r', mmap=False)

                except:
                    print('File', bfield_fname, 'not found')
                    continue

                if run < 0:   #The magnetograms are saved in a different way to the outputs from MF -- I'd rather they weren't but it's easier to flip here than in the Fortran.
                    bx = np.swapaxes(data.variables['bx'][:],0,1)
                    by = np.swapaxes(data.variables['by'][:],0,1)
                    bz = np.swapaxes(data.variables['bz'][:],0,1)

                else:
                    bx = data.variables['bx'][::-1,::-1]
                    by = data.variables['by'][::-1,::-1]
                    bz = data.variables['bz'][::-1,::-1]

                #Need to average these to grid centres to get the FFT to work
                bx0 = 0.5*(bx[:,1:] + bx[:,:-1])
                by0 = 0.5*(by[1:,:] + by[:-1,:])
                bz0 = bz[:,:]

                mag_nx = bz.shape[0]; mag_ny = bz.shape[1]
                mag_dx = (grid.xs[-1] - grid.xs[0])/mag_nx
                mag_dy = (grid.ys[-1] - grid.ys[0])/mag_ny


                def norm2d(vec):
                    mag = np.linalg.norm(vec)
                    if (mag > 0.0):
                        v = vec/mag
                    else:
                        v = np.array([0, 0])
                    return np.array([v[0],v[1],0.0])

                def getFrequencyMatrix(ncells,spacing):
                    freqlist1da =np.roll(np.linspace(-ncells[0]/2,ncells[0]/2-1,ncells[0]),round(ncells[0]/2))/(ncells[0]*spacing[0])
                    freqlist1db =np.roll(np.linspace(-ncells[1]/2,ncells[1]/2-1,ncells[1]),round(ncells[1]/2))/(ncells[1]*spacing[1])
                    return np.array([np.array([np.array([2.0*np.pi*freqlist1da[i],2.0*np.pi*freqlist1db[j]]) for j in range(len(freqlist1db))]) for i  in range(len(freqlist1da))]);

                #Find in -plane vector potential in the winding gauge

                fm = getFrequencyMatrix([mag_nx, mag_ny],[mag_dx, mag_dy]);
                # make the basis

                kparr = np.array([np.array([norm2d(fm[i][j]) for j in range(len(fm[0]))]) for i  in range(len(fm))]);
                kperp = np.array([np.array([np.array([-kparr[i][j][1],kparr[i][j][0],0.0]) for j in range(len(fm[0]))]) for i  in range(len(fm))])
                # note in the k matrix below the k=0 element is set to one so we can divide by it.
                k = np.array([np.array([1.0 if i==j==0 else np.linalg.norm(fm[i][j]) for i in range(len(fm))]) for j  in range(len(fm[0]))]).T

                nx = bz.shape[0]; ny = bz.shape[1]
                aftx = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)
                afty = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)
                aftz = np.zeros([bz.shape[0],bz.shape[1]],dtype=np.complex128)

                fbx = fft2(bx0[:,:]); fby = fft2(by0[:,:]); fbz = fft2(bz0[:,:])

                akperp = -1j*fbz/k
                ## fix i =j  element
                akw = 1j*(-(kparr[:,:,1])*fbx + (kparr[:,:,0])*fby)/k
                ## fix i =j  element
                aftx[:,:] = akperp*kperp[:,:,0]
                afty[:,:] = akperp*kperp[:,:,1]
                aftz[:,:] = akperp*kperp[:,:,2]+akw

                ax0 = ifft2(aftx[:,:])
                ay0 = ifft2(afty[:,:])
                az0 = ifft2(aftz[:,:])
                ax0 = np.real(ax0)
                ay0 = np.real(ay0)
                az0 = np.real(az0)

                ax = np.zeros((nx, ny+1))
                ay = np.zeros((nx+1, ny))

                ax[:,1:-1] = 0.5*(ax0[:,1:] + ax0[:,:-1])
                ay[1:-1,:] = 0.5*(ay0[1:,:] + ay0[:-1,:])

                bz_test = (ay[1:,:] - ay[:-1,:])/mag_dx - (ax[:,1:] - ax[:,:-1])/mag_dy

                #print('Vector potential test', np.max(np.abs(bz[1:-1,1:-1] - bz_test[1:-1,1:-1]))/np.max(np.abs(bz[1:-1,1:-1])))
                #This vector potential should be reasonably OK... Need code to test though

                hfield = np.sqrt(np.abs(ax0*bx0 + ay0*by0 + az0*bz0))

                if run < 0:
                    h_ref.append(np.sum(np.abs(hfield)*mag_dx*mag_dy))
                else:
                    h_all[run].append(np.sum(np.abs(hfield)*mag_dx*mag_dy))

        plt.plot(h_ref, c= 'black', linestyle = 'dashed', label = 'LARE Reference')

        for run in runs[1:]:
            plt.plot(h_all[ri-1], label = ('Run %d' % run))

        plt.legend()

        plt.show()


if len(sys.argv) > 1:
    run_min = int(sys.argv[1])
else:
    run_min = 0


if len(sys.argv) > 2:
    run_max = int(sys.argv[2])
else:
    run_max = 1


compute_inplane_helicity(run_min,run_max)


